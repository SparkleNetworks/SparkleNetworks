<#@ template debug="true" hostSpecific="true" #>
<#@ output extension=".tt.cs" #>
<#@ Assembly Name="System.Core.dll" #>
<#@ Assembly Name="System.Xml.dll" #>
<#@ Assembly Name="System.Xml.Linq.dll" #>
<#@ Assembly Name="System.Windows.Forms.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #> //------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a T4 template.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

<#
//===================================
// Initialisation
//===================================

var projectPath = Path.GetDirectoryName(Path.GetDirectoryName(this.Host.TemplateFile));
var projectName = Path.GetFileName(projectPath);
var solutionPath =  Path.GetDirectoryName(projectPath);
#>
// solutionPath:            <#= solutionPath.Replace(solutionPath, "<solution>") #>
// projectPath:             <#= projectPath.Replace(solutionPath, "<solution>") #>
// projectName:             <#= projectName #>

<#

//===================================
// LOAD FROM FILES
//===================================

var interfacesFromFiles = new List<Repository>();
WriteLine("// codegen: getting list of interfaces from files in project path");
try {
	foreach (var file in Directory.GetFiles(projectPath, "I*Repository.cs")) {
		string iname = Path.GetFileNameWithoutExtension(file);
		string name = iname.Substring(1, iname.IndexOf("Repository") - 1);
		interfacesFromFiles.Add(new Repository {
			Interface = iname,
			Name = name,
		});
	}
	WriteLine("// codegen: found " + interfacesFromFiles.Count + " interfaces");
} catch (Exception ex){
	WriteLine("// codegen: failed ");
	WriteLine(ex.ToString());
}
WriteLine(string.Empty);

//===================================
// LOAD FROM ASSEMBLY
//===================================

var interfacesFromAssembly = new List<Repository>();
WriteLine("// codegen: getting list of interfaces from compiled assembly");
bool ok = true;
var assemblyDir = Path.Combine(projectPath,   "bin", "debug");
var dependencies = new string[] { "Sparkle.Infrastructure", "Sparkle.Entities" };
var assemblyPath = Path.Combine(projectPath, "bin", "debug", projectName + ".dll");
var displayAssemblyPath = "<solution>\\" + assemblyPath.Substring(assemblyPath.IndexOf(projectName));
if (!File.Exists(assemblyPath)) {
	ok = false;
	WriteLine("// codegen: file not found " + assemblyPath);
} else {
	WriteLine("// codegen: file found " + displayAssemblyPath);
}

Assembly ass = null;
Type repoAttr = null;
Type[] types = null;
PropertyInfo repoAttrName = null;
if (ok) {
	try {
		Write("// codegen: loading assembly and its dependencies: ");
		foreach (var dep in dependencies) {
			try {
				Write(dep);
				var depAssemblyPath = Path.Combine(assemblyDir, dep + ".dll");
				//Assembly.LoadFrom(depAssemblyPath);
				Assembly.Load(File.ReadAllBytes(depAssemblyPath));
				Write(", ");
			} catch (Exception ex) {
				WriteLine(string.Empty);
				WriteLine("// codegen: failed to load dependant assembly " + dep);
				WriteLine(ex.ToString());
			}
		}
		Write(projectName);
		WriteLine(string.Empty);
		//ass = Assembly.LoadFrom(assemblyPath);
		ass = Assembly.Load(File.ReadAllBytes(assemblyPath));
        repoAttr = ass.GetType("Sparkle.Data.RepositoryAttribute");
		if (repoAttr == null)
			throw new InvalidOperationException("Cannot find type Sparkle.Data.RepositoryAttribute");
		else
			WriteLine("// codegen: repository attribute type is " + repoAttr.AssemblyQualifiedName);
        repoAttrName = repoAttr.GetProperty("Name");
		types = ass.GetExportedTypes();
		WriteLine("// codegen: assembly loaded with " + types.Length + " public types");
	} catch (Exception ex) {
		ok = false;
		WriteLine("// codegen: failed to load assembly");
		WriteLine(ex.ToString());
	}
}

if (ok) {
	try {
        foreach (Type type in types) {
            if (!type.IsInterface)
                continue;

            object[] attrs = type.GetCustomAttributes(repoAttr, false);
            foreach (object attr in attrs) {
				if (repoAttr.IsInstanceOfType(attr)) {
					string iname = type.Name;
					string name = (string)repoAttrName.GetValue(attr, null);
					if (name == null)
						name = iname.Substring(1, iname.IndexOf("Repository") - 1);
					interfacesFromAssembly.Add(new Repository {
						Interface = type.Name,
						Name = name,
					});
				} else {
				}
            }
        }



		//var ifaces = types.Where
		//WriteLine("// codegen: loading assembly");
	} catch (Exception ex) {
		ok = false;
		WriteLine("// codegen: failed to load assembly");
		WriteLine(ex.ToString());
	}
}

var interfaces = interfacesFromAssembly.OrderBy(x => x.Name).ToList();

#>

namespace Sparkle.Data.Networks
{
    using System;

// codegen: writing factory interface
	
    /// <summary>
    /// Provides access to all data access repositories.
    /// </summary>
    public partial interface IRepositoryFactory : IDisposable
    {
<#
foreach (var item in interfaces) {
#>
		<#= item.Interface #> <#= item.Name #> { get; }
<#
}
#>
    }
	
// codegen: writing factory class
	/*
    public partial class RepositoryFactory : IRepositoryFactory
    {
<#
foreach (var item in interfaces) {
#>
		<#= item.Interface #> IRepositoryFactory.<#= item.Name #> { get { return this.provider.<#= item.Name #>; } }
<#
}
#>
    }
	*/
}

// codegen: ended
<#+

public class Repository {
	public string Interface { get; set; }
	public string Name { get; set; }
}



#>