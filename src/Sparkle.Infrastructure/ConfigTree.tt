<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension=".tt.cs" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="Microsoft.CSharp" #>
<#@ assembly name="System.Data" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Reflection" #>//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a T4 template.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

<#
//===================================
// Initialisation
//===================================

var projectPath = Path.GetDirectoryName(this.Host.TemplateFile);
var projectName = Path.GetFileName(projectPath);
var solutionPath =  Path.GetDirectoryName(projectPath);
#>
// solutionPath:            <#= solutionPath.Replace(solutionPath, "<solution>") #>
// projectPath:             <#= projectPath.Replace(solutionPath, "<solution>") #>
// projectName:             <#= projectName #>

<#
    bool ok = true;
    var sparkleInfraAssPath = Path.Combine(projectPath, "bin\\debug\\sparkle.infrastructure.dll");
    Assembly sparkleInfraAss = null;
    if (!File.Exists(sparkleInfraAssPath)){
        
        this.WriteLine("// codegen: Assembly " + "Sparkle.Infrastructure" + " could not be loaded.");
    }

    if (ok) {
        try {
            sparkleInfraAss = Assembly.Load(File.ReadAllBytes(sparkleInfraAssPath));
        } catch (Exception ex) {
            this.WriteLine("// codegen: Assembly " + "Sparkle.Infrastructure" + " could not be loaded.");
            this.WriteLine(ex.ToString().Replace(Environment.NewLine, Environment.NewLine + "// "));
            ok = false;
        }
        this.WriteLine("// codegen: Assembly " + "Sparkle.Infrastructure" + " loaded.");
    }

    var entries = new List<AppConfigurationEntry>();
    if (ok) {
        //Type type = typeof(string);
        //type.FullName

        try {
            var sparkleInfraTypes = sparkleInfraAss.GetExportedTypes();
            Type confRepoType = sparkleInfraTypes.First(t => t.FullName == "Sparkle.Infrastructure.Data.SqlConfigurationRepository");
            dynamic repo = Activator.CreateInstance(confRepoType, "Data Source=SparkleSqlDev;Initial Catalog=SparkleSystems;Integrated Security=True");
            //this.Write(repo.FindApplicationId("Networks", "localhost", "Sparkle").ToString());
            dynamic keys = repo.FetchKeys();
            foreach (dynamic key in keys) {
                entries.Add(new AppConfigurationEntry {
                    //Id = key.Id,
                    Key = key.Key,
                    KeyId = key.KeyId,
                    IsRequired = key.IsRequired,
                    BlitableType = key.BlittableType,
                    IsCollection = key.IsCollection,
                    Summary = key.Summary,
                    DefaultRawValue = key.DefaultRawValue,
                    IsKey = true,
                });
            }
        } catch (Exception ex) {
            this.WriteLine("// codegen: Could not get configuration keys.");
            this.WriteLine(ex.ToString().Replace(Environment.NewLine, Environment.NewLine + "// "));
            ok = false;
        }
        this.WriteLine("// codegen: Configuration keys: " + entries.Count + ".");
    }
    
    var children = new List<AppConfigurationEntry>();
    if (ok) {
        foreach (var entry in entries) {
            if (!entry.Key.Contains('.')) {
                children.Add(entry);
                continue;
            }

            var parts = entry.Key.Split('.');
            var childs = children;
            AppConfigurationEntry parent = null;
            foreach (string part in parts.Take(parts.Length - 1)) {
                parent = childs.FirstOrDefault(e => e.Key == part);
                if (parent != null) {
                    if (parent.Children == null)
                        parent.Children = new List<AppConfigurationEntry>();
                    childs = parent.Children;
                } else {
                    parent = new AppConfigurationEntry {
                        Key = part,
                        Children = new List<AppConfigurationEntry>(),
                    };
                    childs.Add(parent);
                    childs = parent.Children;
                }
            }
            parent.Children.Add(entry);
        }
    }
#>

#if !SSC
using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Linq;
using Sparkle.Infrastructure.Data;

namespace Sparkle.Infrastructure {
<#
    if (ok) {
        var sb = new StringBuilder();
        AppConfigurationEntry.AppendTree(sb, children);
        this.Write(sb.ToString());
    }

#>
}
#endif

<#+
    public class AppConfigurationEntry {
        //public int Id { get; set; }
        public bool IsKey { get;set;}
        public int KeyId { get; set; }
        public string Key { get; set; }
        //public string RawValue { get; set; }
        //public IList<string> RawValues { get; set; }
        public bool IsRequired { get; set; }
        public string BlitableType { get; set; }
        public bool IsCollection { get; set; }
        public string Summary { get; set; }
        public string DefaultRawValue { get; set; }

        public string CsharpType {
            get
            {
                switch (this.BlitableType)
                {
                    case "System.String":
                        return "string";
                    case "System.Int32":
                        return "int";
                    case "Nullable<System.Int32>":
                        return "int?";
                    case "System.Boolean":
                        return "bool";
                    case "System.Guid":
                        return "Guid";
                    default:
                        return this.BlitableType;
                }
            }
        }

        public bool IsValueType {
            get
            {
                switch (this.BlitableType)
                {
                    case "System.Int32":
                    case "System.Boolean":
                    case "System.Guid":
                        return true;
                    default:
                        return false;
                }
            }
        }

        public bool IsNullableValueType {
            get
            {
                switch (this.BlitableType)
                {
                    case "Nullable<System.Int32>":
                    case "Nullable<System.Boolean>":
                    case "Nullable<System.Guid>":
                        return true;
                    default:
                        return false;
                }
            }
        }

        public string NonNullableValueType {
            get
            {
                if (this.BlitableType.StartsWith("Nullable<") & this.BlitableType.EndsWith(">"))
                {
                    return this.BlitableType.Substring(9, this.BlitableType.Length - 10);
                }
                else if (this.BlitableType.EndsWith("?"))
                {
                    return this.BlitableType.Substring(0, this.BlitableType.Length - 1);
                }

                return null;
            }
        }

        public bool IsReferenceType {
            get { return !this.IsValueType; }
        }

        public AppConfigurationEntry Parent {get;set;}
        public List<AppConfigurationEntry> Children {get;set;}

        public static void AppendTree(StringBuilder sb, List<AppConfigurationEntry> entries) {
            sb.AppendLine("  [GeneratedCode(\"t4\", \"1.0.0.0\")]");
            sb.AppendLine("  public partial class ConfigTree {");
            AppendTreeImpl(sb, entries, "ConfigTree", "  ");
            sb.AppendLine("  }");
        }

        public static void AppendTreeImpl(StringBuilder sb, List<AppConfigurationEntry> entries, string parent, string indent) {
            string indent0 = "  ";
            string indent1 = indent + indent0;
            string indent2 = indent1 + indent0;
            string indent3 = indent2 + indent0;
            string indent4 = indent3 + indent0;

            sb.Append(indent1);
            sb.AppendLine("private IDictionary<string, AppConfigurationEntry> values;");
            sb.AppendLine("");

            sb.Append(indent1);
            sb.AppendLine("internal " + parent + "(IDictionary<string, AppConfigurationEntry> values) {");
            sb.Append(indent2);
            sb.AppendLine("this.values = values;");
            sb.Append(indent1);
            sb.AppendLine("}");
            sb.AppendLine("");

            foreach (var entry in entries.OrderBy(k => k.Key)) {
                string key = entry.Key.Substring(entry.Key.LastIndexOf('.') + 1);
                if (entry.IsKey) {
                    sb.Append(indent1);
                    sb.AppendLine("/// <summary>");
                    sb.Append(indent1);
                    sb.Append("/// ");
                    sb.AppendLine(entry.Summary);
                    sb.Append(indent1);
                    sb.AppendLine("/// </summary>");
                    if (entry.IsCollection) {
                        sb.Append(indent1);
                        sb.AppendLine("public IList<" + entry.CsharpType + "> " + key + " {");
                        sb.Append(indent2);
                        sb.AppendLine("get { return _" + key + " ?? (_" + key + " = ConfigTree.GetValues<" + entry.CsharpType + ">(this.values, \"" + entry.Key + "\")); }");
                        //sb.Append(indent3);
                        //sb.AppendLine("return ");
                        //sb.Append("return _" + key + " ?? (_" + key + " = values[\"" + entry.Key + "\"].RawValues");
                        //sb.Append(".Where(x => x != null)");
                        //sb.Append(".Select(x => )");
                        //sb.Append(".ToList());");
                        //sb.AppendLine("");
                        //sb.Append(indent2);
                        //sb.AppendLine("}");
                        sb.Append(indent1);
                        sb.AppendLine("}");
                        sb.Append(indent1);
                        sb.AppendLine("private IList<" + entry.CsharpType + "> _" + key + ";");
                    } else {
                        if (entry.DefaultRawValue != null) {
                            sb.Append(indent1);
                            sb.AppendLine("// default value: " + entry.DefaultRawValue);
                        } else {
                            sb.Append(indent1);
                            sb.AppendLine("// default value is null");
                        }
                        sb.Append(indent1);
                        sb.AppendLine("public " + entry.CsharpType + " " + key + " {");
                        sb.Append(indent2);
                        if (entry.IsNullableValueType)
                        sb.AppendLine("get { return ConfigTree.GetNullableValue<" + entry.NonNullableValueType + ">(this.values, \"" + entry.Key + "\"); }");
                        else
                        sb.AppendLine("get { return ConfigTree.GetValue<" + entry.CsharpType + ">(this.values, \"" + entry.Key + "\"); }");
                        sb.Append(indent1);
                        sb.AppendLine("}");
                    }
                } else {
                    sb.Append(indent1);
                    sb.AppendLine("public " + key + "Class " + entry.Key + " {");

                    sb.Append(indent2);
                    sb.AppendLine("get { return _" + key + "Class ?? (_" + key + "Class = new " + key + "Class(this.values)); }");
                    sb.Append(indent1);
                    sb.AppendLine("}");

                    sb.Append(indent1);
                    sb.AppendLine("public class " + entry.Key + "Class {");

                    AppendTreeImpl(sb, entry.Children, key + "Class", indent1);
                    sb.Append(indent1);
                    sb.AppendLine("}");
                    sb.Append(indent1);
                    sb.AppendLine("private " + key + "Class _" + key + "Class;");
                }
                sb.AppendLine();
            }
        }
    }
#>